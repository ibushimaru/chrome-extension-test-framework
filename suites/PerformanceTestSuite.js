/**
 * PerformanceTestSuite - „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÈñ¢ÈÄ£„ÅÆÊ§úË®º„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà
 */

const TestSuite = require('../lib/TestSuite');
const fs = require('fs');
const path = require('path');
const FileSizeAnalyzer = require('../lib/FileSizeAnalyzer');
const PerformanceAnalyzer = require('../lib/PerformanceAnalyzer');

class PerformanceTestSuite extends TestSuite {
    constructor(config) {
        super({
            name: 'Performance Validation',
            description: 'ChromeÊã°ÂºµÊ©üËÉΩ„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË¶Å‰ª∂„ÇíÊ§úË®º',
            config: config
        });

        this.config = config;
        this.setupTests();
    }

    setupTests() {
        // „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅÆÊ§úË®ºÔºàÊîπÂñÑÁâàÔºâ
        this.test('File size limits', async (config) => {
            const analyzer = new FileSizeAnalyzer();
            const analysis = await analyzer.analyze(config.extensionPath);
            const report = analyzer.generateReport();
            
            // Â§ß„Åç„Å™„Éï„Ç°„Ç§„É´„ÅÆË≠¶ÂëäË°®Á§∫
            if (analysis.largeFiles.length > 0) {
                console.warn('   ‚ö†Ô∏è  Large files detected:');
                analysis.largeFiles.forEach(file => {
                    const severity = file.severity === 'critical' ? 'üö®' : 
                                   file.severity === 'error' ? '‚ùå' : '‚ö†Ô∏è';
                    console.warn(`      ${severity} ${file.path}: ${analyzer.formatSize(file.size)}`);
                });
            }
            
            // „Éï„Ç°„Ç§„É´„Çø„Ç§„ÉóÂà•„ÅÆÂàÜÊûêË°®Á§∫
            if (config.verbose) {
                console.log('   üìä File size breakdown:');
                for (const [type, data] of Object.entries(report.byType)) {
                    if (data.count > 0) {
                        console.log(`      - ${type}: ${data.count} files, ${data.totalSize} (${data.percentage})`);
                    }
                }
            }
            
            // ÊèêÊ°à‰∫ãÈ†Ö„ÅÆË°®Á§∫
            analysis.suggestions.forEach(suggestion => {
                console.log(`   üí° ${suggestion.message}`);
                console.log(`      ‚Üí ${suggestion.suggestion}`);
            });
            
            // „ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Å™„Ç®„É©„Éº„Åå„ÅÇ„Çå„Å∞‰æãÂ§ñ„ÇíÊäï„Åí„Çã
            const criticalErrors = analysis.warnings.filter(w => w.severity === 'critical');
            if (criticalErrors.length > 0) {
                const error = new Error(`Critical file size issues detected: ${criticalErrors.length} files exceed limits`);
                error.code = 'FILE_SIZE_CRITICAL';
                error.severity = 'critical';
                error.details = {
                    files: criticalErrors,
                    report: report
                };
                error.suggestions = analysis.suggestions;
                throw error;
            }
            
            // „Ç®„É©„Éº„É¨„Éô„É´„ÅÆË≠¶Âëä„Åå„ÅÇ„ÇãÂ†¥Âêà
            const errors = analysis.warnings.filter(w => w.severity === 'error');
            if (errors.length > 0) {
                const error = new Error(`File size issues detected: ${errors.length} files are too large`);
                error.code = 'FILE_SIZE_ERROR';
                error.severity = 'high';
                error.details = {
                    files: errors,
                    report: report
                };
                error.suggestions = analysis.suggestions;
                throw error;
            }
        });

        // ÁîªÂÉèÊúÄÈÅ©Âåñ„ÅÆÊ§úË®º
        this.test('Image optimization', async (config) => {
            const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg'];
            const images = await this.findFilesByExtension(config.extensionPath, imageExtensions);
            
            for (const imagePath of images) {
                const stats = fs.statSync(imagePath);
                const sizeMB = stats.size / 1024 / 1024;
                
                // Â§ß„Åç„Å™ÁîªÂÉè„Éï„Ç°„Ç§„É´„ÅÆË≠¶Âëä
                if (sizeMB > 0.5) {
                    console.warn(`   ‚ö†Ô∏è  Large image: ${path.basename(imagePath)} (${sizeMB.toFixed(2)}MB)`);
                }
                
                // „Ç¢„Ç§„Ç≥„É≥„Çµ„Ç§„Ç∫„ÅÆÊ§úË®º
                if (imagePath.includes('icon') || imagePath.includes('logo')) {
                    if (sizeMB > 0.1) {
                        console.warn(`   ‚ö†Ô∏è  Icon file too large: ${path.basename(imagePath)}`);
                    }
                }
            }
        });

        // JavaScriptÊúÄÈÅ©Âåñ„ÅÆÊ§úË®ºÔºàPerformanceAnalyzerÁµ±ÂêàÔºâ
        this.test('JavaScript optimization', async (config) => {
            const analyzer = new PerformanceAnalyzer();
            const issues = await analyzer.analyze(config.extensionPath);
            
            // Heavy computationÈñ¢ÈÄ£„ÅÆÂïèÈ°å„ÇíÊäΩÂá∫
            const computationIssues = issues.filter(issue => issue.type === 'heavy_computation');
            const bundleIssues = issues.filter(issue => issue.type === 'large_bundle' || issue.type === 'duplicate_code');
            
            // JavaScriptÁâπÊúâ„ÅÆÂïèÈ°å„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            const jsFiles = await this.findFilesByExtension(config.extensionPath, ['.js']);
            
            for (const jsFile of jsFiles) {
                const content = fs.readFileSync(jsFile, 'utf8');
                const stats = fs.statSync(jsFile);
                
                // console.log„ÅÆÈÅéÂâ∞‰ΩøÁî®
                const consoleLogs = (content.match(/console\.(log|debug|info)/g) || []).length;
                if (consoleLogs > 10) {
                    console.warn(`   ‚ö†Ô∏è  Excessive console logging in ${path.basename(jsFile)}: ${consoleLogs} occurrences`);
                }
                
                // „Éá„Éê„ÉÉ„Ç∞„Ç≥„Éº„Éâ„ÅÆÊ§úÂá∫
                if (/debugger;/g.test(content)) {
                    throw new Error(`debugger statement found in ${path.basename(jsFile)}`);
                }
            }
            
            // Heavy computationÂïèÈ°å„ÅÆË°®Á§∫
            if (computationIssues.length > 0) {
                console.warn('   ‚ö†Ô∏è  Heavy computation patterns detected:');
                computationIssues.forEach(issue => {
                    const severity = issue.severity === 'critical' ? 'üö®' : '‚ùå';
                    console.warn(`      ${severity} ${issue.file}: ${issue.description}`);
                    if (issue.suggestion) {
                        console.warn(`         üí° ${issue.suggestion}`);
                    }
                });
            }
            
            // Bundle issues
            if (bundleIssues.length > 0) {
                console.warn('   ‚ö†Ô∏è  Bundle optimization issues:');
                bundleIssues.forEach(issue => {
                    console.warn(`      ‚ö†Ô∏è  ${issue.file}: ${issue.description}`);
                });
            }
            
            // Critical issues
            const criticalIssues = [...computationIssues, ...bundleIssues].filter(i => i.severity === 'critical');
            if (criticalIssues.length > 0) {
                const error = new Error(`${criticalIssues.length} critical JavaScript optimization issues detected`);
                error.code = 'JS_OPTIMIZATION_CRITICAL';
                error.severity = 'critical';
                error.details = criticalIssues;
                throw error;
            }
        });

        // ‰æùÂ≠òÈñ¢‰øÇ„ÅÆÊ§úË®º
        this.test('Dependencies check', async (config) => {
            const packageJsonPath = path.join(config.extensionPath, 'package.json');
            
            if (fs.existsSync(packageJsonPath)) {
                const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                const dependencies = {
                    ...packageJson.dependencies,
                    ...packageJson.devDependencies
                };
                
                const depCount = Object.keys(dependencies).length;
                
                if (depCount > 50) {
                    console.warn(`   ‚ö†Ô∏è  Large number of dependencies: ${depCount}`);
                }
                
                // node_modules„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
                const nodeModulesPath = path.join(config.extensionPath, 'node_modules');
                if (fs.existsSync(nodeModulesPath)) {
                    const error = new Error('node_modules directory should not be included in extension');
                    error.code = 'NODE_MODULES';
                    error.category = 'PERFORMANCE_ERROR';
                    throw error;
                }
            }
        });

        // CSSÊúÄÈÅ©Âåñ„ÅÆÊ§úË®º
        this.test('CSS optimization', async (config) => {
            const cssFiles = await this.findFilesByExtension(config.extensionPath, ['.css']);
            
            for (const cssFile of cssFiles) {
                const content = fs.readFileSync(cssFile, 'utf8');
                const stats = fs.statSync(cssFile);
                
                // Â§ß„Åç„Å™CSS„Éï„Ç°„Ç§„É´
                if (stats.size > 100 * 1024) { // 100KB
                    console.warn(`   ‚ö†Ô∏è  Large CSS file: ${path.basename(cssFile)} (${(stats.size / 1024).toFixed(0)}KB)`);
                }
                
                // ÈùûÂäπÁéá„Å™„Çª„É¨„ÇØ„Çø
                const universalSelectors = (content.match(/\*/g) || []).length;
                if (universalSelectors > 10) {
                    console.warn(`   ‚ö†Ô∏è  Many universal selectors in ${path.basename(cssFile)}: ${universalSelectors}`);
                }
                
                // Ê∑±„ÅÑ„Éç„Çπ„Éà
                const deepSelectors = content.match(/([^\s]+\s+){5,}/g) || [];
                if (deepSelectors.length > 0) {
                    console.warn(`   ‚ö†Ô∏è  Deep CSS selectors in ${path.basename(cssFile)}: ${deepSelectors.length}`);
                }
            }
        });

        // „É°„É¢„É™„É™„Éº„ÇØ„ÅÆÊΩúÂú®ÁöÑ„É™„Çπ„ÇØÔºàPerformanceAnalyzerÁµ±ÂêàÔºâ
        this.test('Memory leak prevention', async (config) => {
            const analyzer = new PerformanceAnalyzer();
            const issues = await analyzer.analyze(config.extensionPath);
            const report = analyzer.generateReport();
            
            // „É°„É¢„É™„É™„Éº„ÇØÈñ¢ÈÄ£„ÅÆÂïèÈ°å„ÇíÊäΩÂá∫
            const memoryLeakIssues = issues.filter(issue => issue.type === 'memory_leak');
            
            if (memoryLeakIssues.length > 0) {
                console.warn('   ‚ö†Ô∏è  Memory leak patterns detected:');
                memoryLeakIssues.forEach(issue => {
                    const severity = issue.severity === 'critical' ? 'üö®' : 
                                   issue.severity === 'high' ? '‚ùå' : '‚ö†Ô∏è';
                    console.warn(`      ${severity} ${issue.file}: ${issue.description}`);
                    if (issue.occurrences) {
                        console.warn(`         Found ${issue.occurrences} occurrences`);
                    }
                });
                
                // È´ò„Çª„Éô„É™„ÉÜ„Ç£„ÅÆÂïèÈ°å„Åå„ÅÇ„Çå„Å∞„Ç®„É©„Éº
                const highSeverityIssues = memoryLeakIssues.filter(i => i.severity === 'high' || i.severity === 'critical');
                if (highSeverityIssues.length > 0) {
                    const error = new Error(`${highSeverityIssues.length} high-severity memory leak patterns detected`);
                    error.code = 'MEMORY_LEAK_DETECTED';
                    error.severity = 'high';
                    error.details = highSeverityIssues;
                    throw error;
                }
            }
        });

        // Service WorkerÂäπÁéáÊÄßÔºàPerformanceAnalyzerÁµ±ÂêàÔºâ
        this.test('Service worker efficiency', async (config) => {
            const manifestPath = path.join(config.extensionPath, 'manifest.json');
            const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
            
            if (manifest.background && manifest.background.service_worker) {
                const swPath = path.join(config.extensionPath, manifest.background.service_worker);
                
                if (fs.existsSync(swPath)) {
                    const content = fs.readFileSync(swPath, 'utf8');
                    const analyzer = new PerformanceAnalyzer();
                    
                    // Service worker specific analysis
                    analyzer.detectMemoryLeaks(content, path.basename(swPath));
                    analyzer.detectHeavyComputation(content, path.basename(swPath));
                    
                    // Get any issues found
                    const swIssues = analyzer.issues.filter(i => i.file === path.basename(swPath));
                    
                    if (swIssues.length > 0) {
                        console.warn('   ‚ö†Ô∏è  Service worker performance issues:');
                        swIssues.forEach(issue => {
                            console.warn(`      ‚ùå ${issue.description}`);
                        });
                    }
                    
                    // Ê∞∏Á∂öÁöÑ„Å™Êé•Á∂ö„ÅÆ‰ΩøÁî®
                    if (/chrome\.runtime\.connect/g.test(content)) {
                        console.warn('   ‚ö†Ô∏è  Persistent connections in service worker may impact performance');
                    }
                    
                    // ÈÅéÂ∫¶„Å™„Çπ„Éà„É¨„Éº„Ç∏„Ç¢„ÇØ„Çª„Çπ
                    const storageAccess = (content.match(/chrome\.storage\.(local|sync)\.(get|set)/g) || []).length;
                    if (storageAccess > 20) {
                        console.warn(`   ‚ö†Ô∏è  Frequent storage access in service worker: ${storageAccess} calls`);
                    }
                    
                    // Critical issues in service worker
                    const criticalSWIssues = swIssues.filter(i => i.severity === 'critical' || i.severity === 'high');
                    if (criticalSWIssues.length > 0) {
                        throw new Error(`Service worker has ${criticalSWIssues.length} critical performance issues`);
                    }
                }
            }
        });

        // „É≠„Éº„Éá„Ç£„É≥„Ç∞ÊôÇÈñì„ÅÆÊúÄÈÅ©ÂåñÔºàPerformanceAnalyzerÁµ±ÂêàÔºâ
        this.test('Loading time optimization', async (config) => {
            const manifestPath = path.join(config.extensionPath, 'manifest.json');
            const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
            const analyzer = new PerformanceAnalyzer();
            const issues = await analyzer.analyze(config.extensionPath);
            
            // Bundle size issues
            const bundleSizeIssues = issues.filter(i => i.type === 'bundle_size' || i.type === 'large_file');
            
            if (bundleSizeIssues.length > 0) {
                console.warn('   ‚ö†Ô∏è  Bundle size issues affecting load time:');
                bundleSizeIssues.forEach(issue => {
                    console.warn(`      ‚ùå ${issue.description}`);
                    if (issue.suggestion) {
                        console.warn(`         üí° ${issue.suggestion}`);
                    }
                });
            }
            
            // Content scripts„ÅÆË™≠„ÅøËæº„Åø„Çø„Ç§„Éü„É≥„Ç∞
            if (manifest.content_scripts) {
                manifest.content_scripts.forEach((script, index) => {
                    if (!script.run_at || script.run_at === 'document_idle') {
                        // document_idle„ÅØ„Éá„Éï„Ç©„É´„Éà„ÅßËâØ„ÅÑÈÅ∏Êäû
                    } else if (script.run_at === 'document_start') {
                        console.warn(`   ‚ö†Ô∏è  Content script ${index} runs at document_start - may impact page load`);
                    }
                    
                    // Check if content scripts are too large
                    if (script.js) {
                        script.js.forEach(jsFile => {
                            const filePath = path.join(config.extensionPath, jsFile);
                            if (fs.existsSync(filePath)) {
                                const stats = fs.statSync(filePath);
                                if (stats.size > 100 * 1024) {
                                    console.warn(`   ‚ö†Ô∏è  Large content script: ${jsFile} (${(stats.size / 1024).toFixed(0)}KB)`);
                                }
                            }
                        });
                    }
                });
            }
            
            // Web accessible resources„ÅÆÊï∞
            if (manifest.web_accessible_resources) {
                let totalResources = 0;
                manifest.web_accessible_resources.forEach(resource => {
                    totalResources += resource.resources ? resource.resources.length : 0;
                });
                
                if (totalResources > 50) {
                    console.warn(`   ‚ö†Ô∏è  Many web accessible resources: ${totalResources}`);
                }
            }
            
            // Check for critical bundle size issues
            const criticalBundleIssues = bundleSizeIssues.filter(i => i.severity === 'critical' || i.severity === 'high');
            if (criticalBundleIssues.length > 0) {
                throw new Error(`${criticalBundleIssues.length} critical loading time issues detected`);
            }
        });

        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÔºàPerformanceAnalyzerÁµ±ÂêàÔºâ
        this.test('Animation performance', async (config) => {
            const analyzer = new PerformanceAnalyzer();
            const issues = await analyzer.analyze(config.extensionPath);
            
            // DOM and CSS performance issues
            const domIssues = issues.filter(i => i.type === 'excessive_dom');
            const cssIssues = issues.filter(i => i.type === 'css_performance');
            
            // Display DOM manipulation issues
            if (domIssues.length > 0) {
                console.warn('   ‚ö†Ô∏è  DOM performance issues detected:');
                domIssues.forEach(issue => {
                    console.warn(`      ‚ùå ${issue.file}: ${issue.description}`);
                    if (issue.suggestion) {
                        console.warn(`         üí° ${issue.suggestion}`);
                    }
                });
            }
            
            // CSS performance check
            const cssFiles = await this.findFilesByExtension(config.extensionPath, ['.css']);
            
            for (const cssFile of cssFiles) {
                const content = fs.readFileSync(cssFile, 'utf8');
                
                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅÆ‰ΩøÁî®
                const animations = content.match(/@keyframes|animation:|transition:/g) || [];
                
                if (animations.length > 20) {
                    console.warn(`   ‚ö†Ô∏è  Many animations in ${path.basename(cssFile)}: ${animations.length}`);
                }
                
                // transform‰ª•Â§ñ„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                const nonTransformAnimations = content.match(/animation:.*?(margin|padding|width|height|top|left|right|bottom)/g) || [];
                if (nonTransformAnimations.length > 0) {
                    console.warn(`   ‚ö†Ô∏è  Non-transform animations detected in ${path.basename(cssFile)} - may cause reflow`);
                }
            }
            
            // Display CSS issues from analyzer
            if (cssIssues.length > 0) {
                console.warn('   ‚ö†Ô∏è  CSS performance issues:');
                cssIssues.forEach(issue => {
                    console.warn(`      ‚ö†Ô∏è  ${issue.file}: ${issue.description}`);
                });
            }
            
            // Check for critical animation/DOM issues
            const criticalAnimationIssues = [...domIssues, ...cssIssues].filter(i => i.severity === 'high' || i.severity === 'critical');
            if (criticalAnimationIssues.length > 0) {
                throw new Error(`${criticalAnimationIssues.length} critical animation/rendering performance issues detected`);
            }
        });
    }

    /**
     * „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÇíÂàÜÊûê
     */
    async analyzeFileSizes(dir) {
        const results = [];
        
        const walk = (currentDir) => {
            const entries = fs.readdirSync(currentDir);
            
            entries.forEach(entry => {
                const fullPath = path.join(currentDir, entry);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory() && !entry.startsWith('.') && entry !== 'node_modules') {
                    walk(fullPath);
                } else if (stat.isFile()) {
                    results.push({
                        path: path.relative(dir, fullPath),
                        size: stat.size
                    });
                }
            });
        };
        
        walk(dir);
        return results;
    }

    /**
     * Êã°ÂºµÂ≠ê„Åß„Éï„Ç°„Ç§„É´„ÇíÊ§úÁ¥¢
     */
    async findFilesByExtension(dir, extensions) {
        const files = [];
        const exts = Array.isArray(extensions) ? extensions : [extensions];
        
        const walk = (currentDir) => {
            const entries = fs.readdirSync(currentDir);
            
            entries.forEach(entry => {
                const fullPath = path.join(currentDir, entry);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory() && !entry.startsWith('.') && entry !== 'node_modules') {
                    walk(fullPath);
                } else if (stat.isFile()) {
                    if (exts.some(ext => fullPath.endsWith(ext))) {
                        files.push(fullPath);
                    }
                }
            });
        };
        
        walk(dir);
        return files;
    }
}

module.exports = PerformanceTestSuite;