/**
 * StructureTestSuite - „Éï„Ç°„Ç§„É´ÊßãÈÄ†„ÅÆÊ§úË®º„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà
 */

const TestSuite = require('../lib/TestSuite');
const fs = require('fs');
const path = require('path');
const FileNameValidator = require('../lib/FileNameValidator');
const DirectoryAnalyzer = require('../lib/DirectoryAnalyzer');
const ConsoleAnalyzer = require('../lib/ConsoleAnalyzer');

class StructureTestSuite extends TestSuite {
    constructor(config) {
        super({
            name: 'Structure Validation',
            description: 'ChromeÊã°ÂºµÊ©üËÉΩ„ÅÆ„Éï„Ç°„Ç§„É´ÊßãÈÄ†„ÇíÊ§úË®º',
            config: config
        });

        this.config = config;
        this.setupTests();
    }

    setupTests() {
        // „Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†„ÅÆÁ¢∫Ë™ç
        this.test('Directory structure', async (config) => {
            const rootFiles = await this.readDirectory('');
            const directories = [];
            const files = [];
            
            for (const item of rootFiles) {
                const fullPath = path.join(config.extensionPath, item);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory()) {
                    directories.push(item);
                } else {
                    files.push(item);
                }
            }
            
            console.log(`   üìÅ Directories: ${directories.join(', ') || 'none'}`);
            console.log(`   üìÑ Root files: ${files.length}`);
            
            // Êé®Â•®„Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†
            const recommendedDirs = ['js', 'css', 'images', 'icons', '_locales'];
            const missingRecommended = recommendedDirs.filter(dir => !directories.includes(dir));
            
            if (missingRecommended.length > 0) {
                console.log(`   üí° Consider creating: ${missingRecommended.join(', ')}`);
            }
        });

        // „Éï„Ç°„Ç§„É´ÂëΩÂêçË¶èÂâáÔºàÊîπÂñÑÁâàÔºâ
        this.test('File naming conventions', async (config) => {
            const fileValidator = new FileNameValidator({
                checkPlatformCompatibility: true,
                autoFixSuggestions: true,
                excludeManager: this.config.excludeManager
            });
            
            const results = await fileValidator.validateDirectory(config.extensionPath);
            
            // „Ç®„É©„Éº„Å®Ë≠¶Âëä„ÅÆË°®Á§∫
            let hasIssues = false;
            
            // „ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Å™„Ç®„É©„Éº„ÇíË°®Á§∫
            const criticalErrors = results.errors.filter(e => e.severity === 'critical');
            if (criticalErrors.length > 0) {
                criticalErrors.forEach(error => {
                    console.error(`   üö® ${error.message}`);
                    if (error.details) console.error(`      ‚Üí ${error.details}`);
                });
                hasIssues = true;
            }
            
            // „Åù„ÅÆ‰ªñ„ÅÆ„Ç®„É©„Éº„ÇíË°®Á§∫
            const otherErrors = results.errors.filter(e => e.severity !== 'critical');
            if (otherErrors.length > 0) {
                otherErrors.forEach(error => {
                    console.warn(`   ‚ùå ${error.message}`);
                    if (error.details) console.warn(`      ‚Üí ${error.details}`);
                });
                hasIssues = true;
            }
            
            // ÈáçË¶Å„Å™Ë≠¶Âëä„ÇíË°®Á§∫
            const highWarnings = results.warnings.filter(w => w.severity === 'high');
            if (highWarnings.length > 0) {
                highWarnings.forEach(warning => {
                    console.warn(`   ‚ö†Ô∏è  ${warning.message}`);
                });
                hasIssues = true;
            }
            
            // ‰øÆÊ≠£ÊèêÊ°à„ÇíË°®Á§∫
            if (results.suggestions.length > 0 && config.verbose) {
                console.log('   üí° Suggested fixes:');
                results.suggestions.forEach(suggestion => {
                    console.log(`      - Rename "${suggestion.original}" to "${suggestion.suggested}"`);
                });
            }
            
            // „Çµ„Éû„É™„Éº
            if (results.problematicFiles > 0) {
                console.log(`   üìä ${results.problematicFiles}/${results.totalFiles} files have naming issues`);
            }
            
            // „ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Å™„Ç®„É©„Éº„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ‰æãÂ§ñ„ÇíÊäï„Åí„Çã
            if (criticalErrors.length > 0) {
                const error = new Error(`Critical file naming issues detected: ${criticalErrors.length} files`);
                error.code = 'FILE_NAMING_CRITICAL';
                error.details = results;
                throw error;
            }
        });

        // ÈñãÁô∫Áî®„Éï„Ç°„Ç§„É´„ÅÆÈô§Â§ñÁ¢∫Ë™ç
        this.test('No development files', async (config) => {
            // „Éó„É≠„Éï„Ç°„Ç§„É´„Åß„Çπ„Ç≠„ÉÉ„Éó„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
            if (config.profile?.skipTests?.includes('No development files')) {
                // „Çπ„Ç≠„ÉÉ„Éó„ÅÆÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºà„ÉÜ„Çπ„Éà„ÅØÂÆüË°å„Åï„Çå„Å™„ÅÑÔºâ
                return;
            }
            
            // ÈñãÁô∫„Éï„Ç°„Ç§„É´„ÉÅ„Çß„ÉÉ„ÇØ„Åß„ÅØÈô§Â§ñ„ÇíÁÑ°Ë¶ñ„Åó„Å¶„Åô„Åπ„Å¶„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂèñÂæó
            const allFiles = await this.getAllFiles('', [], { skipExclude: true });
            
            // „Éá„Éï„Ç©„É´„Éà„ÅÆÈñãÁô∫„Éï„Ç°„Ç§„É´„É™„Çπ„Éà
            const defaultDevFiles = [
                '.git', '.gitignore', '.gitattributes',
                'node_modules', 'package.json', 'package-lock.json',
                'yarn.lock', 'pnpm-lock.yaml',
                '.env', '.env.local', '.env.development',
                'webpack.config.js', 'rollup.config.js', 'vite.config.js',
                'tsconfig.json', 'babel.config.js',
                '.eslintrc', '.prettierrc',
                'Makefile', 'Dockerfile',
                '.DS_Store', 'Thumbs.db',
                '*.log', '*.map', '*.test.js', '*.spec.js',
                'TODO.txt', 'TODO.md', 'NOTES.txt', 'NOTES.md',
                '.vscode', '.idea', '*.swp', '*.tmp'
            ];
            
            // Ë®≠ÂÆö„Åã„ÇâÈô§Â§ñ„Åô„Çã„Éï„Ç°„Ç§„É´„ÇíÂèñÂæó
            const allowedDevFiles = config.allowedDevFiles || [];
            const devFiles = defaultDevFiles.filter(file => !allowedDevFiles.includes(file));
            
            const foundDevFiles = [];
            
            for (const file of allFiles) {
                const basename = path.basename(file);
                const dirname = path.dirname(file);
                
                // Ë®±ÂèØ„É™„Çπ„Éà„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØÔºàglob „Éë„Çø„Éº„É≥ÂØæÂøúÔºâ
                let isAllowed = false;
                for (const allowed of allowedDevFiles) {
                    if (allowed === basename) {
                        isAllowed = true;
                        break;
                    }
                    // glob „Éë„Çø„Éº„É≥„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
                    if (allowed.includes('*') || allowed.includes('?') || allowed.includes('[')) {
                        if (this.simpleGlobMatch(allowed, file) || this.simpleGlobMatch(allowed, basename)) {
                            isAllowed = true;
                            break;
                        }
                    }
                }
                
                if (isAllowed) {
                    continue;
                }
                
                // ÈñãÁô∫„Éï„Ç°„Ç§„É´„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
                for (const pattern of devFiles) {
                    // ÂÆåÂÖ®‰∏ÄËá¥
                    if (pattern === basename) {
                        foundDevFiles.push(file);
                        break;
                    }
                    
                    // „Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ
                    if (pattern.startsWith('*')) {
                        const ext = pattern.substring(1);
                        if (basename.endsWith(ext)) {
                            foundDevFiles.push(file);
                            break;
                        }
                    }
                    
                    // „Éá„Ç£„É¨„ÇØ„Éà„É™Âêç„ÉÅ„Çß„ÉÉ„ÇØ
                    if (!pattern.includes('*') && !pattern.includes('.')) {
                        // node_modules„ÅÆÁâπÂà•Âá¶ÁêÜ - „É´„Éº„Éà„É¨„Éô„É´„ÅÆ„Åø„ÉÅ„Çß„ÉÉ„ÇØ
                        if (pattern === 'node_modules') {
                            const dirParts = dirname.split(path.sep);
                            // „É´„Éº„Éà„É¨„Éô„É´„ÅÆnode_modules„ÅÆ„Åø„ÇíÂïèÈ°å„Å®„Åó„Å¶Êâ±„ÅÜ
                            if (dirParts.length === 1 && dirParts[0] === 'node_modules') {
                                foundDevFiles.push(file);
                                break;
                            } else if (dirParts.length === 0 && basename === 'node_modules') {
                                // node_modules„Éá„Ç£„É¨„ÇØ„Éà„É™Ëá™‰Ωì
                                foundDevFiles.push(file);
                                break;
                            }
                        } else {
                            // „Åù„ÅÆ‰ªñ„ÅÆÈñãÁô∫„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅØÈÄöÂ∏∏ÈÄö„Çä„ÉÅ„Çß„ÉÉ„ÇØ
                            const dirParts = dirname.split(path.sep);
                            if (dirParts.includes(pattern)) {
                                foundDevFiles.push(file);
                                break;
                            }
                        }
                    }
                }
            }
            
            if (foundDevFiles.length > 0) {
                // „Éá„Ç£„É¨„ÇØ„Éà„É™Âà•„Å´„Éï„Ç°„Ç§„É´„ÇíÈõÜË®à
                const filesByDir = {};
                foundDevFiles.forEach(file => {
                    const dir = path.dirname(file) || 'root';
                    if (!filesByDir[dir]) {
                        filesByDir[dir] = 0;
                    }
                    filesByDir[dir]++;
                });
                
                // Â§ö„ÅÑÈ†Ü„Å´„ÇΩ„Éº„Éà
                const sortedDirs = Object.entries(filesByDir)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5); // ‰∏ä‰Ωç5„Éá„Ç£„É¨„ÇØ„Éà„É™
                
                console.log(`   üìÑ Development files found: ${foundDevFiles.length} files`);
                if (sortedDirs.length > 0) {
                    console.log('   Top directories:');
                    sortedDirs.forEach(([dir, count]) => {
                        console.log(`      ‚Ä¢ ${dir}: ${count} files`);
                    });
                    if (Object.keys(filesByDir).length > 5) {
                        console.log(`      ‚Ä¢ ... and ${Object.keys(filesByDir).length - 5} more directories`);
                    }
                }
                
                // package.json„ÅåË¶ã„Å§„Åã„Å£„ÅüÂ†¥Âêà„ÅÆÁâπÂà•„Å™„É°„ÉÉ„Çª„Éº„Ç∏
                if (foundDevFiles.some(f => path.basename(f) === 'package.json')) {
                    console.log('   üí° If package.json is intentional, add to config:');
                    console.log('      "allowedDevFiles": ["package.json"]');
                }
                
                // ‰∏ÄËà¨ÁöÑ„Å™ÂØæÁ≠ñ
                console.log('   üí° To exclude directories, add to config:');
                const topDir = sortedDirs[0]?.[0];
                if (topDir && topDir !== 'root') {
                    console.log(`      "exclude": ["${topDir}/**"]`);
                }
                
                // Ë©≥Á¥∞„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏ÔºàÊúÄÂàù„ÅÆ10„Éï„Ç°„Ç§„É´„ÅÆ„ÅøÔºâ
                const displayFiles = foundDevFiles.slice(0, 10);
                const remaining = foundDevFiles.length > 10 ? ` and ${foundDevFiles.length - 10} more` : '';
                const error = new Error(`Development files found: ${displayFiles.join(', ')}${remaining}`);
                error.code = 'DEVELOPMENT_FILES';
                error.category = 'CODE_QUALITY';
                throw error;
            }
        });

        // ÂøÖÈ†à„Éï„Ç°„Ç§„É´„ÅÆÂ≠òÂú®Á¢∫Ë™ç
        this.test('Required files present', async (config) => {
            const requiredFiles = ['manifest.json'];
            const missingFiles = [];
            
            for (const file of requiredFiles) {
                if (!await this.fileExists(file)) {
                    missingFiles.push(file);
                }
            }
            
            if (missingFiles.length > 0) {
                throw new Error(`Missing required files: ${missingFiles.join(', ')}`);
            }
            
            // Êé®Â•®„Éï„Ç°„Ç§„É´
            const recommendedFiles = ['README.md', 'LICENSE'];
            for (const file of recommendedFiles) {
                if (!await this.fileExists(file)) {
                    console.log(`   üí° Consider adding: ${file}`);
                }
            }
        });

        // „É¢„Ç∏„É•„Éº„É´ÊßãÈÄ†„ÅÆÊ§úË®º
        this.test('Module structure', async (config) => {
            const allFiles = await this.getAllFiles();
            const jsFiles = allFiles.filter(file => file.endsWith('.js'));
            
            // ES6„É¢„Ç∏„É•„Éº„É´„ÅÆ‰ΩøÁî®Á¢∫Ë™ç
            let moduleCount = 0;
            let legacyCount = 0;
            
            for (const jsFile of jsFiles) {
                const content = await this.loadFile(jsFile);
                
                if (content.includes('import ') || content.includes('export ')) {
                    moduleCount++;
                } else {
                    legacyCount++;
                }
            }
            
            if (moduleCount > 0 && legacyCount > 0) {
                console.warn('   ‚ö†Ô∏è  Mixed module systems detected. Consider using ES6 modules consistently.');
            }
            
            // manifest.json„Åß„ÅÆtype: "module"Á¢∫Ë™ç
            const manifest = await this.loadManifest(config);
            if (manifest.background?.service_worker && moduleCount > 0) {
                if (!manifest.background.type || manifest.background.type !== 'module') {
                    console.warn('   ‚ö†Ô∏è  ES6 modules used but background.type is not "module"');
                }
            }
        });

        // ÈáçË§á„Éï„Ç°„Ç§„É´„ÅÆÊ§úÂá∫
        this.test('No duplicate files', async (config) => {
            const allFiles = await this.getAllFiles();
            const filesBySize = {};
            
            // „Çµ„Ç§„Ç∫„Åß„Ç∞„É´„Éº„ÉóÂåñ
            for (const file of allFiles) {
                const size = await this.getFileSize(file);
                if (!filesBySize[size]) {
                    filesBySize[size] = [];
                }
                filesBySize[size].push(file);
            }
            
            // Âêå„Åò„Çµ„Ç§„Ç∫„ÅÆ„Éï„Ç°„Ç§„É´„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            const duplicates = [];
            for (const [size, files] of Object.entries(filesBySize)) {
                if (files.length > 1) {
                    // ÂÜÖÂÆπ„ÇíÊØîËºÉÔºàÁ∞°ÊòìÁöÑ„Å´„Éï„Ç°„Ç§„É´Âêç„ÅßÂà§Êñ≠Ôºâ
                    const baseNames = files.map(f => path.basename(f));
                    const uniqueNames = [...new Set(baseNames)];
                    
                    if (uniqueNames.length < files.length) {
                        duplicates.push(...files);
                    }
                }
            }
            
            if (duplicates.length > 0) {
                console.warn(`   ‚ö†Ô∏è  Possible duplicate files: ${duplicates.join(', ')}`);
            }
        });

        // „Éï„Ç°„Ç§„É´Á∑®Êàê„ÅÆÁ¢∫Ë™ç
        this.test('File organization', async (config) => {
            const allFiles = await this.getAllFiles();
            const misplacedFiles = [];
            
            for (const file of allFiles) {
                const ext = path.extname(file).toLowerCase();
                const dir = path.dirname(file);
                const basename = path.basename(file);
                
                // „É´„Éº„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÊï¥ÁêÜ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Éï„Ç°„Ç§„É´
                if (dir === '.' && !['manifest.json', 'README.md', 'LICENSE', 'CHANGELOG.md'].includes(basename)) {
                    if (['.js', '.css', '.html'].includes(ext)) {
                        misplacedFiles.push(file);
                    }
                }
                
                // ÈÅ©Âàá„Å™„Éá„Ç£„É¨„ÇØ„Éà„É™„Å´„ÅÇ„Çã„Åã
                if (ext === '.js' && !dir.includes('js') && dir !== '.') {
                    console.log(`   üí° JavaScript file not in js/ directory: ${file}`);
                }
                if (ext === '.css' && !dir.includes('css') && dir !== '.') {
                    console.log(`   üí° CSS file not in css/ directory: ${file}`);
                }
                if (['.png', '.jpg', '.jpeg', '.gif', '.svg'].includes(ext) && 
                    !dir.includes('image') && !dir.includes('icon') && !dir.includes('assets')) {
                    console.log(`   üí° Image file not in appropriate directory: ${file}`);
                }
            }
            
            if (misplacedFiles.length > 0) {
                console.warn(`   ‚ö†Ô∏è  Files in root directory should be organized: ${misplacedFiles.join(', ')}`);
            }
        });

        // „Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†„ÅÆÊ∑±Â∫¶ÂàÜÊûê
        this.test('Directory depth analysis', async (config) => {
            const analyzer = new DirectoryAnalyzer({
                maxDepth: 5,
                maxPathLength: 260,
                maxFilesPerDirectory: 50,
                excludeManager: this.config.excludeManager
            });
            
            const analysis = await analyzer.analyze(config.extensionPath);
            const report = analyzer.generateReport();
            
            // „É°„Éà„É™„ÇØ„Çπ„ÅÆË°®Á§∫
            if (config.verbose) {
                console.log('   üìä Directory structure metrics:');
                console.log(`      - Total files: ${report.summary.totalFiles}`);
                console.log(`      - Total directories: ${report.summary.totalDirectories}`);
                console.log(`      - Max depth: ${report.summary.maxDepth}`);
                console.log(`      - Average depth: ${report.summary.averageDepth}`);
                if (analysis.metrics.deepestPath) {
                    console.log(`      - Deepest path: ${analysis.metrics.deepestPath}`);
                }
            }
            
            // ÂïèÈ°å„ÅÆË°®Á§∫
            if (analysis.issues.length > 0) {
                analysis.issues.forEach(issue => {
                    const icon = issue.severity === 'critical' ? 'üö®' :
                                issue.severity === 'high' ? '‚ùå' :
                                issue.severity === 'medium' ? '‚ö†Ô∏è' : 'üí°';
                    console.warn(`   ${icon} ${issue.message}`);
                    if (issue.details) {
                        console.warn(`      ‚Üí ${issue.details}`);
                    }
                    if (issue.recommendation) {
                        console.log(`      üí° ${issue.recommendation}`);
                    }
                });
            }
            
            // ÊèêÊ°à„ÅÆË°®Á§∫
            if (analysis.suggestions.length > 0 && config.verbose) {
                console.log('   üí° Structure improvements:');
                analysis.suggestions.forEach(suggestion => {
                    console.log(`      - ${suggestion.suggestion}`);
                    if (suggestion.examples) {
                        suggestion.examples.forEach(example => {
                            console.log(`        ‚Ä¢ ${example}`);
                        });
                    }
                });
            }
            
            // „ÉÑ„É™„ÉºË°®Á§∫ÔºàË©≥Á¥∞„É¢„Éº„ÉâÔºâ
            if (config.verbose && analysis.issues.length > 0) {
                console.log('   üìÅ Directory tree:');
                const treeLines = report.tree.split('\n');
                treeLines.slice(0, 20).forEach(line => {
                    console.log(`      ${line}`);
                });
                if (treeLines.length > 20) {
                    console.log(`      ... (${treeLines.length - 20} more lines)`);
                }
            }
            
            // „ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Å™ÂïèÈ°å„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ‰æãÂ§ñ„ÇíÊäï„Åí„Çã
            const criticalIssues = analysis.issues.filter(i => i.severity === 'critical');
            if (criticalIssues.length > 0) {
                const error = new Error(`Critical directory structure issues: ${criticalIssues[0].message}`);
                error.code = 'DIRECTORY_STRUCTURE_CRITICAL';
                error.details = analysis;
                throw error;
            }
        });

        // console.log‰ΩøÁî®„ÅÆÊ§úË®º
        this.test('Console logging usage', async (config) => {
            // „Éó„É≠„Éï„Ç°„Ç§„É´Ë®≠ÂÆö„Åß„Çπ„Ç≠„ÉÉ„Éó„Åô„ÇãÂ†¥Âêà
            if (config.profile?.skipTests?.includes('No console.log usage')) {
                // „Çπ„Ç≠„ÉÉ„Éó„ÅÆÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºà„ÉÜ„Çπ„Éà„ÅØÂÆüË°å„Åï„Çå„Å™„ÅÑÔºâ
                return;
            }
            
            const consoleAnalyzer = new ConsoleAnalyzer(config);
            const allFiles = await this.getAllFiles();
            const jsFiles = allFiles.filter(file => file.endsWith('.js'));
            
            const results = [];
            let totalConsoleUsage = 0;
            
            for (const file of jsFiles) {
                const content = await this.loadFile(file);
                const result = consoleAnalyzer.analyze(content, file);
                
                if (result.count > 0) {
                    results.push({
                        file,
                        ...result
                    });
                    totalConsoleUsage += result.count;
                }
            }
            
            // „Çµ„Éû„É™„ÉºÁîüÊàê
            const summary = consoleAnalyzer.generateSummary(results);
            
            // ÁµêÊûú„ÅÆË°®Á§∫
            if (totalConsoleUsage > 0) {
                console.log(`   üìä Console usage analysis:`);
                console.log(`      - Total console calls: ${totalConsoleUsage}`);
                
                // „Éï„Ç°„Ç§„É´„Çø„Ç§„ÉóÂà•„ÅÆË°®Á§∫ÔºàÁí∞Â¢ÉÂà•„Å´Êï¥ÁêÜÔºâ
                const fileTypeLabels = {
                    'production': 'Êú¨Áï™„Ç≥„Éº„Éâ',
                    'service-worker': 'Service Worker',
                    'content-script': 'Content Script',
                    'development': 'ÈñãÁô∫Áî®',
                    'test': '„ÉÜ„Çπ„Éà',
                    'production-build': '„Éì„É´„ÉâÊàêÊûúÁâ©'
                };
                
                Object.entries(summary.byFileType).forEach(([fileType, data]) => {
                    const label = fileTypeLabels[fileType] || fileType;
                    console.log(`      - ${label}: ${data.count} calls in ${data.files} files`);
                });
                
                // ÈñæÂÄ§„ÇíË∂Ö„Åà„Å¶„ÅÑ„Çã„Éï„Ç°„Ç§„É´„ÅÆË°®Á§∫
                const exceededFiles = results.filter(r => r.exceeds);
                if (exceededFiles.length > 0) {
                    console.warn(`   ‚ö†Ô∏è  Files exceeding console usage threshold:`);
                    exceededFiles.forEach(result => {
                        const typeLabel = fileTypeLabels[result.fileType] || result.fileType;
                        console.warn(`      - ${result.file} (${typeLabel}): ${result.count} calls, threshold: ${result.threshold}`);
                        
                        // Âä†Èáç„Ç´„Ç¶„É≥„Éà„ÅåÂÆüÈöõ„ÅÆ„Ç´„Ç¶„É≥„Éà„Å®Áï∞„Å™„ÇãÂ†¥Âêà„ÅØË°®Á§∫
                        if (result.weightedCount !== result.count) {
                            console.log(`        üìä Weighted count: ${result.weightedCount} (error/warn have lower weight)`);
                        }
                        
                        if (result.details.hasDebugComments) {
                            console.log(`        üí° Contains debug comments - consider removing for production`);
                        }
                    });
                }
                
                // ÊèêÊ°à„ÅÆË°®Á§∫
                if (summary.suggestions.length > 0) {
                    console.log(`   üí° Recommendations:`);
                    summary.suggestions.forEach(suggestion => {
                        console.log(`      - ${suggestion}`);
                    });
                }
            }
            
            // „ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Å™ÂïèÈ°å„Åå„ÅÇ„ÇãÂ†¥Âêà
            const criticalResults = results.filter(r => r.severity === 'critical');
            if (criticalResults.length > 0) {
                // Ë©≥Á¥∞„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Çí‰ΩúÊàê
                const details = criticalResults
                    .slice(0, 5) // ÊúÄÂàù„ÅÆ5„Éï„Ç°„Ç§„É´„ÇíË°®Á§∫
                    .map(r => `${r.file}: ${r.count} occurrences (threshold: ${r.threshold})`)
                    .join('\n      - ');
                
                const remaining = criticalResults.length > 5 ? `\n      - ... (and ${criticalResults.length - 5} more files)` : '';
                
                const error = new Error(`Excessive console.log usage detected:\n      - ${details}${remaining}`);
                error.code = 'CODE_QUALITY';
                error.category = 'CODE_QUALITY';
                error.details = results;
                error.severity = 'critical';
                throw error;
            }
        });
    }
}

module.exports = StructureTestSuite;